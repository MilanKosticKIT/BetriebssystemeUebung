\documentclass[12pt,a4paper]{article}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{comment}
\renewcommand{\contentsname}{Inhaltsverzeichnis}

\begin{document}
\tableofcontents
\newpage
\section{Einleitung}
\subsection{Ziel}
Als Ergänzung zu den Inhalten der Vorlesung "Betriebsysteme" und zur Vertiefung des Systemnahen Programmierens unter C++, wurde das Dateisystem MyFs erstellt.
\subsection{Technische Umgebung}
Da Dateisystemverwaltung auf Kernel Ebene stattfindet, wurde File System In User Space (Fuse) als Schnittstelle zwischen dem Kernel und MyFs benutzt. Somit stand auch das Zielbetriebsystem fest, es wurde Linux aufgrund der besseren Handhabung von Fuse unter Linux.
Entwickelt wurde das Dateisystem mit hilfe von XCode unter MacOS in C++.
Zur Versionsverwaltung und zur Projektverwaltung wurde GitHub benutzt.
\subsection{Struktur der Containerdatei}
\label{subsec:struktur}
Die Containerdatei wurde intern in 5 Abschnitte unterteilt.
\\ 
\begin{enumerate}
\item Superblock  $\Rightarrow$ \textit{Informationen über das Dateisystem} 
\item DMAP $\Rightarrow$ \textit{Übersicht freier Datenblöcke}
\item FAT	$\Rightarrow$ \textit{Verlinkung von Datenblöcken zu Dateien}  
\item Root $\Rightarrow$ \textit{Informationen über Dateien} 
\item Datenblöcke $\Rightarrow$ \textit{Dateien in MyFs geteilt in Blöcke} 
\end{enumerate}
\subsection{Projektstruktur}
Bei der Projektplanung haben wir uns an dem MVC Pattern orientiert.
Wir haben getrennte Klassen für die einzelnen Abschnitte (siehe \ref{subsec:struktur}), welche die Logik/Modell stellen.
Dazu gibt es die Klasse "FilesystemIO" welche Methoden für das Schreiben in die Containerdatei, sowie das Lesen daraus zur Verfügung stellt und in dem Pattern als View angesehen werden kann.
Objekte dieser Klassen werden von einer übergeordneten Klasse "MyFS" erzeugt.
Diese ruft Methoden aus den Klassen auf, um die Ausführung des Programms zu steuern und kann als Control in dem MVC Pattern angesehen werden.
\newpage
\section{Implementierung}
\subsection{Superblock}
Der Superblock enthält wichtige Informationen über das Dateisystem an sich. In ihm werden sowohl Informationen die für das Betriebssystem und den Benutzer relevant sind wie Größe des Dateisystems, der freie Speicherplatz und maximale Speichergröße. Als auch für den Betrieb des Dateisystems wichtige Daten wie die jeweiligen Startadressen der Bestandteile und die Größe dieser. Von der Implementierung ist es eine Struct mit 16 bit unsigned Integer werten.


\subsection{DMAP}
Die DMAP ist dazu da, einen Überblick zu schaffen, welche Datenblöcke frei sind.
Im Endeffekt handelt es sich um einen Integer Array dessen Länge, der Anzahl vorhandenen Datenblöcke im Dateisystem entspricht. Dabei bedeutet eine "0" an Stelle x im Array, dass der x-te Datenblock frei ist, dementsprechend eine "1", dass der Datenblock belegt ist.  
\\
Die Klasse DMAP stellt 5 öffentliche Methoden, es können Blöcke als belegt und frei gesetzt werden.
Außerdem gibt die Methode "getFreeBlock" den nächsten freien Block zurück. Wir haben uns dazu entschlossen, den Wert für den nächsten freien Block jederzeit im Hintergrund als private Variable zu halten und erst nachdem dieser Block beschrieben wurde, den neuen nächsten freien Block zu berechnen.
 % TODO eigener Abschnitt zum Thema sichern und laden
Für die Initialisierung, wurden zwei Methoden implementiert "getAll" welchen den kompletten DMAP Array zurückgibt, und "setAll" welche den DMAP Array mit dem übergebenen Array überschreibt. Diese zwei Methoden werden benutzt, um die komplette DMAP in die Containerdatei auf der Festplatte zu schreiben bzw. sie wiederherzustellen.

\subsection{FAT}
Die Aufgabe der FAT ist die Verbindung zwischen einzelner Datenblöcke zu einer Datei herzustellen. Die FAT realisieren wir als einen Array. Die Größe entspricht dabei der Menge an Datenblöcke die unser Dateisystem zur Verfügung hat. In unserem Fall 65535. Die Verknüpfung erfolgt dabei indem der Wert des Arrays an einer bestimmten Stelle denn Index des nächsten Datenblocks beinhaltet. Hinzu kommt noch ein Terminierendes Zeichen, welches zeigt, dass die Datei zu ende ist, bei uns erfüllt diese Aufgabe der Index 65535 da dieser außerhalb des Arrays liegt. 
Zum auslesen der FAT wurde eine Methode "iterateFat" implementiert, diese bekommt den Index des ersten Datenblockes, sowie eine leere Liste übergeben. Die Methode geht die Verkettung beginnend mit dem ersten Datenblock durch und speichert die Indexe aller zusammenhängenden Datenblöcke chronologisch in die Liste. Zum Löschen einer Datei aus der FAT wird nur der erste Datenblock  an die Methode "deleteFromFAT" übergeben. In dieser wird durch die Verkettung iteriert und alle zusammenhängende Einträge gelöscht.  
Zum einfügen neuer Informationen in die FAT stellt diese zwei verschiedene Methoden zur Verfügung. Zum einen "addNextToFAT" dieser werden zwei Indexe übergeben, die Methode stellt eine Verkettung zwischen den ersten und dem zweiten Datenblock her.
Und die zweite Methode "addLastToFAT", welche an den übergebenen Index den Terminalen Index schreibt.
 
\subsection{ROOT}


\begin{comment}
\lstinputlisting
[caption={Superblock}
\label{lst:superblock},
captionpos=b,language=C++,firstline=29,lastline=41]
{../includes/myfs-structs.h}


\lstinputlisting
[caption={DMAP}
\label{lst:dmap},
captionpos=b,language=C++, basicstyle=\ttfamily,
keywordstyle=\color{blue}\ttfamily,
stringstyle=\color{purple}\ttfamily,
commentstyle=\color{gray}\ttfamily,
]%
{../src/dmap.cpp}
\end{comment}

\end{document}